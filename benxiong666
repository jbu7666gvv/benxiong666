-- 环境检查和安全函数定义
local function safeRequire(func, fallback)
    local success, result = pcall(func)
    return success and result or fallback
end

-- 缓存常用函数
local task_wait = task.wait
local collectgarbage_collect = collectgarbage
local loadstring = loadstring or load

print("脚本开始执行...")

-- 改进的 HTTP 获取函数
local function httpGet(url)
    print("尝试HTTP请求: " .. url)
    local success, result = pcall(function()
        -- 方法1: 标准HttpGet
        if game and game.HttpGet then
            print("使用 game:HttpGet")
            return game:HttpGet(url, true)
        -- 方法2: Synapse
        elseif syn and syn.request then
            print("使用 syn.request")
            local response = syn.request({
                Url = url,
                Method = "GET",
                Timeout = 10
            })
            return response.Body
        -- 方法3: KRNL/其他执行器
        elseif request then
            print("使用 request")
            local response = request({
                Url = url,
                Method = "GET"
            })
            return response.Body
        -- 方法4: Fluxus
        elseif fluxus and fluxus.request then
            print("使用 fluxus.request")
            local response = fluxus.request({
                Url = url,
                Method = "GET"
            })
            return response.Body
        else
            print("没有可用的 HTTP 方法")
            error("没有可用的 HTTP 方法")
        end
    end)
    
    if success and result and #result > 100 then
        print("HTTP请求成功，长度: " .. #result)
        return result
    else
        print("HTTP请求失败: " .. tostring(result))
        return nil
    end
end

-- 简化的 WindUI 加载函数
local function loadWindUISafely()
    print("开始加载 WindUI...")
    
    -- 使用更可靠的源
    local sources = {
        "https://raw.githubusercontent.com/Footagesus/WindUI/main/src/main.lua",
        "https://cdn.jsdelivr.net/gh/Footagesus/WindUI@main/src/main.lua",
    }
    
    for i, url in ipairs(sources) do
        print("尝试源 " .. i .. ": " .. url)
        local source = httpGet(url)
        if source then
            print("成功获取源 " .. i .. ", 长度: " .. #source)
            local success, lib = pcall(loadstring, source)
            if success and lib then
                print("WindUI 加载成功")
                local ui = lib()
                if ui and ui.CreateWindow then
                    print("WindUI 功能正常")
                    return ui
                else
                    print("WindUI 功能不完整")
                end
            else
                print("WindUI 编译失败: " .. tostring(lib))
            end
        else
            print("源 " .. i .. " 请求失败")
        end
        task_wait(1)
    end
    
    print("所有WindUI源都失败")
    return nil
end

-- 加载 WindUI 库
print("=== 开始加载UI库 ===")
local WindUISuccess, WindUI = pcall(loadWindUISafely)

if not WindUISuccess or not WindUI then
    print("WindUI加载失败")
    -- 直接使用游戏内置通知
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "本熊汉化",
        Text = "WindUI加载失败，请检查网络",
        Duration = 5
    })
    return
else
    print("WindUI加载成功")
    WindUI:Notify({
        Title = "本熊汉化",
        Content = "WindUI加载成功！",
        Duration = 3
    })
end

-- 给UI库初始化时间
task_wait(1)

-- 颜色常量
local COLORS = {
    GRADIENT_START = Color3.fromHex("#00FF87"),
    GRADIENT_END = Color3.fromHex("#60EFFF"),
    BUTTON_START = Color3.fromHex("#FF0F7B"),
    BUTTON_END = Color3.fromHex("#F89B29")
}

-- 图标常量
local KEY_ICON = " 🔑"
local CHECK_ICON = " ✅"

-- 安全调用函数
local function safeCall(func, errorMessage)
    local success, err = pcall(func)
    if not success then
        if WindUI then
            WindUI:Notify({Title = "错误", Content = errorMessage .. ": " .. tostring(err), Duration = 5})
        end
    end
    return success
end

-- 安全的剪贴板操作
local function safeSetClipboard(text)
    local success, err = pcall(function()
        if setclipboard then
            setclipboard(text)
        elseif syn and syn.write_clipboard then
            syn.write_clipboard(text)
        elseif write_clipboard then
            write_clipboard(text)
        else
            error("没有可用的剪贴板方法")
        end
    end)
    return success
end

-- 密钥验证系统（简化版，直接通过）
local KeySystem = {
    ValidKeys = {"秋容", "本熊汉化", "WindUI"},
    CurrentKey = "秋容",
    IsValid = true
}

-- 完全跳过密钥验证
local function requireKeyOnStart()
    print("跳过密钥验证")
    KeySystem.CurrentKey = "秋容"
    KeySystem.IsValid = true
    return true
end

-- 在创建主窗口前验证密钥
print("=== 开始密钥验证 ===")
local keyValid = requireKeyOnStart()
if not keyValid then
    WindUI:Notify({Title = "错误", Content = "密钥验证失败，脚本终止", Duration = 5})
    print("密钥验证失败，脚本终止")
    return
end

print("密钥验证通过，继续执行主界面...")

-- 检查WindUI是否真的可用
print("=== 检查UI库状态 ===")
print("WindUI是否存在:", WindUI ~= nil)
print("WindUI类型:", type(WindUI))
print("CreateWindow方法:", WindUI and type(WindUI.CreateWindow))

if not WindUI or not WindUI.CreateWindow then
    print("WindUI不可用")
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "错误",
        Text = "WindUI功能不完整",
        Duration = 5
    })
    return
end

-- 测试通知功能
if WindUI and WindUI.Notify then
    WindUI:Notify({
        Title = "调试", 
        Content = "密钥验证通过，开始创建UI",
        Duration = 3
    })
else
    print("错误：WindUI.Notify不可用")
    return
end

-- 创建主窗口（添加错误处理）
local Window
local windowSuccess, windowError = pcall(function()
    Window = WindUI:CreateWindow({
        Title = "本熊汉化",
        Icon = "rbxassetid://129260712070622",
        IconThemed = true,
        Author = "本熊汉化",
        Folder = "本熊汉化",
        Size = UDim2.fromOffset(580, 460),
        Transparent = true,
        Theme = "Dark",
        User = {
            Enabled = true,
            Callback = function() 
                if safeSetClipboard("本熊汉化") then
                    WindUI:Notify({Title = "提示", Content = "已复制作者信息", Duration = 2})
                else
                    WindUI:Notify({Title = "错误", Content = "剪贴板复制失败", Duration = 2})
                end
            end,
            Anonymous = true
        },
        SideBarWidth = 200,
        ScrollBarEnabled = true,
        KeySystem = false
    })
end)

if not windowSuccess or not Window then
    print("窗口创建失败:", windowError)
    WindUI:Notify({
        Title = "错误", 
        Content = "窗口创建失败: " .. tostring(windowError),
        Duration = 5
    })
    return
end

print("主窗口创建成功")

-- 渐变文本函数
function gradient(text, startColor, endColor)
    local result = {}
    local length = #text
    
    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        
        table.insert(result, string.format('<font color="rgb(%d,%d,%d)">%s</font>', r, g, b, text:sub(i, i)))
    end
    
    return table.concat(result)
end

-- 加载脚本函数
local function loadScript(url, scriptName)
    if not KeySystem.IsValid then
        WindUI:Notify({Title = "错误", Content = "密钥已失效，请重新验证", Duration = 3})
        return
    end
    
    WindUI:Notify({Title = "提示", Content = "正在加载 " .. scriptName .. "...", Duration = 2})
    
    local success, result = pcall(function()
        local response = httpGet(url)
        if not response or #response < 50 then
            return false, "脚本内容无效或为空"
        end
        
        local loadedFunction, loadError = loadstring(response)
        if not loadedFunction then
            return false, "脚本编译错误: " .. tostring(loadError)
        end
        
        local executeSuccess, executeError = pcall(loadedFunction)
        if not executeSuccess then
            return false, "脚本执行错误: " .. tostring(executeError)
        end
        
        return true
    end)
    
    if success and result then
        WindUI:Notify({Title = "成功", Content = scriptName .. " 加载完成", Duration = 3})
    else
        local errorMsg = success and result or "网络请求失败"
        WindUI:Notify({Title = "错误", Content = scriptName .. " 加载失败: " .. errorMsg, Duration = 5})
    end
end

-- 欢迎弹窗
print("显示欢迎弹窗...")
local Confirmed = false

WindUI:Popup({
    Title = "欢迎使用本熊汉化",
    Icon = "rbxassetid://112682688917044",
    IconThemed = true,
    Content = "本熊汉化 WindUI Lib",  
    Buttons = {
        {
            Title = "退出",
            Callback = function() 
                WindUI:Notify({Title = "提示", Content = "已退出", Duration = 2})
                Window:Destroy()
                return
            end,
            Variant = "Secondary",
        },
        {
            Title = "使用",
            Icon = "arrow-right",
            Callback = function() 
                Confirmed = true 
                WindUI:Notify({Title = "欢迎", Content = "开始使用本熊汉化", Duration = 2})
            end,
            Variant = "Primary",
        }
    }
})

print("等待用户确认...")
-- 等待用户确认，但设置超时
local startTime = tick()
while not Confirmed do
    if tick() - startTime > 30 then -- 30秒超时
        print("等待确认超时，自动继续")
        Confirmed = true
    end
    task_wait(0.1)
end
print("用户确认，继续创建UI...")

-- 添加重新验证按钮
Window:CreateTopbarButton("重新验证", "key", function() 
    KeySystem.IsValid = true
    WindUI:Notify({Title = "成功", Content = "密钥验证通过！", Duration = 3})
end, 990)

Window:CreateTopbarButton("全屏", "battery-plus", function() 
    Window:ToggleFullscreen()
    WindUI:Notify({Title = "提示", Content = "切换全屏模式", Duration = 2})
end, 989)

Window:EditOpenButton({
    Title = "本熊汉化",
    Icon = "monitor",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(COLORS.BUTTON_START, COLORS.BUTTON_END),
    Draggable = true,
})

print("创建标签页...")
local Tabs = {
    Home = Window:Tab({ Title = "主页", Icon = "crown" }),
    Main = Window:Tab({ Title = "99夜", Icon = "zap" }),
    Ninja = Window:Tab({ Title = "死铁轨", Icon = "user" }),
    Oth = Window:Tab({ Title = "偷走脑红", Icon = "heart" }),
    Other = Window:Tab({ Title = "工具", Icon = "settings" })
}

Window:SelectTab(1)

-- 主页内容
Tabs.Home:Paragraph({
    Title = "欢迎使用本熊汉化",
    Desc = "专为Roblox脚本汉化 - 密钥验证系统已启用",
})

Tabs.Home:Paragraph({
    Title = "更新内容",
    Desc = "• 增加了偷走脑红汉化，优化了界面\n• 简化了密钥验证流程",
})

Tabs.Home:Section({Title = "主页"})

Tabs.Home:Button({
    Title = "复制QQ群号",
    Callback = function()
        if safeSetClipboard("168985587") then
            WindUI:Notify({Title = "QQ群号", Content = "群号已复制到剪贴板", Duration = 3})
        else
            WindUI:Notify({Title = "错误", Content = "剪贴板复制失败", Duration = 3})
        end
    end
})

Tabs.Home:Button({
    Title = "复制老鼠快手号",
    Callback = function()
        if safeSetClipboard("lousun7891") then
            WindUI:Notify({Title = "快手号", Content = "快手号已复制到剪贴板", Duration = 3})
        else
            WindUI:Notify({Title = "错误", Content = "剪贴板复制失败", Duration = 3})
        end
    end
})

-- 其他标签页内容
Tabs.Main:Section({Title = "99夜脚本"})
Tabs.Main:Button({
    Title = "加载99夜汉化",
    Callback = function()
        WindUI:Notify({Title = "提示", Content = "加载99夜汉化脚本...", Duration = 3})
        -- 这里可以添加实际的脚本加载代码
    end
})

Tabs.Ninja:Section({Title = "死铁轨脚本"})
Tabs.Ninja:Button({
    Title = "加载死铁轨汉化",
    Callback = function()
        WindUI:Notify({Title = "提示", Content = "加载死铁轨汉化脚本...", Duration = 3})
        -- 这里可以添加实际的脚本加载代码
    end
})

Tabs.Oth:Section({Title = "偷走脑红脚本"})
Tabs.Oth:Button({
    Title = "加载偷走脑红汉化",
    Callback = function()
        WindUI:Notify({Title = "提示", Content = "加载偷走脑红汉化脚本...", Duration = 3})
        -- 这里可以添加实际的脚本加载代码
    end
})

Tabs.Other:Section({Title = "工具"})
Tabs.Other:Button({
    Title = "清理内存",
    Callback = function()
        collectgarbage_collect()
        WindUI:Notify({Title = "提示", Content = "内存清理完成", Duration = 2})
    end
})

Tabs.Other:Button({
    Title = "显示信息",
    Callback = function()
        WindUI:Notify({
            Title = "系统信息", 
            Content = "本熊汉化 - WindUI模式\n密钥状态: 验证通过\n当前密钥: " .. KeySystem.CurrentKey,
            Duration = 5
        })
    end
})

print("界面创建完成，显示成功通知")
WindUI:Notify({
    Title = "本熊汉化", 
    Content = "界面加载完成！密钥验证通过，请选择需要的脚本。",
    Duration = 4
})

print("=== 脚本执行完成 ===")
